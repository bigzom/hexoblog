---
title: jvm和垃圾回收
date: 2019-09-02 10:50:54
tags: [jvm]
---
##### jvm结构
![avtor](/img/jvm.png)
1. 类加载子系统与方法区：加载器将class信心加载进入方法区，方法区，还存在常量池
2. java堆，JVM启动时就存在，java主要工作空间。存放的是java对象实例
<!--more-->
3. 直接内存：java堆外直接向系统申请的内存，速度优于堆内存，大小只受操作系统给出的内存限制。读写频繁的场合可能使用直接内存。
4. 垃圾回收：可以对方法区、java堆、直接内存进行回收。
5. java栈：保存着栈帧（该方法是否运行的标记）、方法、方法参数、局部变量。主要用于java方法的调用
6. 本地方法栈：主要用于本地方法的调用（通常C编写）
7. PC寄存器：每个线程私有空间，无法指定本地方法
8. 执行引擎：执行虚拟机的字节码，既时编译技术
##### jvm堆结构图及分代
1. jv内存分代策略
jvm会根据对象的存活周期将内存划为几块：新生代、老年代、永久代
2. 为什么要分代
 内存空间是连续的，容易造成空间碎片。同时每次垃圾回收都会遍历所有地址，影响性能。所以把不同生命周期的对象放在不同区域，有助于性能提升
- 不同堆代用不同垃圾分收器
- 新生代垃圾回收机制
新生代分区：EDEN、FROM、TO 比例8：1：1
HotSpot采用复制算法对新生代进行回收，新生成的对象在Eden分配空间（大对象直接老年代），如果Eden空间不足时JVM会进行一次Minor GC,Eden区无法回收的对象会放入To区，From区未被回收的对象如果年龄（逃过一次回收+1）超过阀值将会放入老年代，其它放入To区。清空Eden和From,From 和 TO区角色互换(保证每一轮TO区为空).当TO区没有足够空间存放时，由老年代进行保存
##### 垃圾回收算法
1. 引用计数法
当一个对象新增一个对象时，计数+1，删除一个时计数-1，当计数为0时，该对象就会被清除。
缺点：无法处理循环引用问题
2. 复制法
分配两个大小一样的内存空间A、B，将A中正在使用的对象复制进B进行整理，然后清空A。解决了“碎片”问题
缺点：需要两倍空间
3. 标记-清除法
第一阶段：从根节点标记所有被引用的对象
第二阶段：遍历整个堆清楚未标记对象
缺点：产生内存碎片，回收时应用程序必须暂停
4. 标记-整理法
标记清楚法+复制法的结合体
第一阶段：从根节点标记被引用的对象
第二阶段：把未被标记的对象从堆中清除，再把标记对象经行整理顺序放在堆中某一块
解决了碎片问题也解决了2倍空间问题

##### 垃圾收集器
- Scavenge（次收集器）
作用范围年轻代，当Eden空间不足时，或无法申请新空间时会执行。频率高，速度快。
- Full GC(全收集器)
当老年代或者持久代堆空间不够时会触发，时间较长。超过3-5秒，既为过长
可以使用System.gc()显示启动全收集器（不会马上执行）

- 新生代收集器
a.串行收集器（Serial）
  一个CPU/一条收集线程去完成GC工作，可以使用-xx:+UseSeriaIGC打开
b.并行收集器（parNew）
  多个cup/多个线程收集，多核情况下有用。使用-xx:ParallelGCTHreads=<N>(N启动线程数)
  出发点：减少安全检测时间
c.Parallel Scavenge 收集器
 与parNew类似
 出发点：减少垃圾回收时间
- 老年代收集器
不能用复制算法，用的标记整理算法
 a.Serial old 可以兼容新生代全部收集器
 b.Parallel old 只能和Parallel Scavenge工作

 C.CMS(并发标记清除) 可以和：Serial、parNew一起工作
  并发：用户线程与GC线程交替运行
  并行：只有GC线程

  - G1收集器
  堆空间被分割成一些相同大小的堆区域，每一个都是连续范围的虚拟内存。特定的区域集合像旧的收集器一样被指派为相同的角色（伊甸：eden、幸存：survivor、年老：old），但是它们没有一个固定大小。这在内存使用上提供了更强大的灵活性。
  理论上优于：CMS
